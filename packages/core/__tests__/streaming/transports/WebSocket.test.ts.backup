import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import { WebSocketTransport } from '../../../src/streaming/transports/WebSocket'
import type { TransportConfig } from '../../../src/streaming/transports/types'

// Mock WebSocket
class MockWebSocket {
  static CONNECTING = 0
  static OPEN = 1
  static CLOSING = 2
  static CLOSED = 3

  public readyState: number = MockWebSocket.CONNECTING
  public onopen: ((event: any) => void) | null = null
  public onmessage: ((event: any) => void) | null = null
  public onerror: ((event: any) => void) | null = null
  public onclose: ((event: any) => void) | null = null

  constructor(public url: string, public protocols?: string | string[]) {
    // Simulate async connection
    setTimeout(() => {
      this.readyState = MockWebSocket.OPEN
      if (this.onopen) {
        this.onopen({ type: 'open' })
      }
    }, 0)
  }

  send(data: string): void {
    if (this.readyState !== MockWebSocket.OPEN) {
      throw new Error('WebSocket is not open')
    }
  }

  close(code?: number, reason?: string): void {
    this.readyState = MockWebSocket.CLOSED
    if (this.onclose) {
      this.onclose({ type: 'close', code: code || 1000, reason: reason || '' })
    }
  }

  // Helper for testing
  simulateMessage(data: any): void {
    if (this.onmessage) {
      this.onmessage({ data: JSON.stringify(data) })
    }
  }

  simulateError(error: any): void {
    if (this.onerror) {
      this.onerror({ error })
    }
  }
}

global.WebSocket = MockWebSocket as any

describe('WebSocketTransport', () => {
  let transport: WebSocketTransport
  let mockWs: MockWebSocket

  beforeEach(() => {
    vi.clearAllMocks()
  })

  afterEach(async () => {
    if (transport) {
      transport.close()
      // Give time for cleanup
      await new Promise(resolve => setTimeout(resolve, 10))
    }
  })

  describe('constructor', () => {
    it('should create instance with config', () => {
      const config: TransportConfig = {
        endpoint: 'ws://localhost:3000/stream',
        headers: { 'Authorization': 'Bearer token' },
      }

      transport = new WebSocketTransport(config)
      expect(transport).toBeInstanceOf(WebSocketTransport)
    })

    it('should initialize in idle state', () => {
      transport = new WebSocketTransport({ endpoint: 'ws://localhost:3000/stream' })
      expect(transport.getState()).toBe('idle')
    })

    it('should convert http endpoint to ws', () => {
      transport = new WebSocketTransport({ endpoint: 'http://localhost:3000/stream' })
      expect(transport).toBeInstanceOf(WebSocketTransport)
    })

    it('should convert https endpoint to wss', () => {
      transport = new WebSocketTransport({ endpoint: 'https://localhost:3000/stream' })
      expect(transport).toBeInstanceOf(WebSocketTransport)
    })
  })

  describe('connect', () => {
    it('should establish WebSocket connection', async () => {
      transport = new WebSocketTransport({ endpoint: 'ws://localhost:3000/stream' })

      const connectedListener = vi.fn()
      transport.on('connected', connectedListener)

      await transport.connect()

      expect(transport.getState()).toBe('connected')
      expect(connectedListener).toHaveBeenCalled()
    })

    it('should emit connecting event', async () => {
      transport = new WebSocketTransport({ endpoint: 'ws://localhost:3000/stream' })

      const connectingListener = vi.fn()
      transport.on('connecting', connectingListener)

      await transport.connect()

      expect(connectingListener).toHaveBeenCalled()
    })

    it('should handle connection errors', async () => {
      const OriginalWebSocket = global.WebSocket

      class ErrorWebSocket extends MockWebSocket {
        constructor(url: string, protocols?: string | string[]) {
          super(url, protocols)
          setTimeout(() => {
            this.readyState = MockWebSocket.CLOSED
            if (this.onerror) {
              this.onerror({ error: new Error('Connection failed') })
            }
            if (this.onclose) {
              this.onclose({ type: 'close', code: 1006, reason: 'Connection failed' })
            }
          }, 5)
        }
      }

      global.WebSocket = ErrorWebSocket as any

      transport = new WebSocketTransport({
        endpoint: 'ws://localhost:3000/stream',
        reconnect: false,
      })

      const errorListener = vi.fn()
      transport.on('error', errorListener)

      await transport.connect()

      // Give time for error event to propagate
      await new Promise(resolve => setTimeout(resolve, 20))

      expect(errorListener).toHaveBeenCalled()

      global.WebSocket = OriginalWebSocket
    })

    it('should support WebSocket protocols', async () => {
      transport = new WebSocketTransport({
        endpoint: 'ws://localhost:3000/stream',
        protocols: ['protocol1', 'protocol2'],
      })

      await transport.connect()

      expect(transport.getState()).toBe('connected')
    })
  })

  describe('send', () => {
    it('should send data through connected transport', async () => {
      transport = new WebSocketTransport({ endpoint: 'ws://localhost:3000/stream' })
      await transport.connect()

      const data = { message: 'Hello' }
      await transport.send(data)

      // Verify no errors thrown
      expect(transport.getState()).toBe('connected')
    })

    it('should throw error if not connected', async () => {
      transport = new WebSocketTransport({ endpoint: 'ws://localhost:3000/stream' })

      await expect(transport.send({ test: 'data' })).rejects.toThrow()
    })

    it('should serialize data as JSON', async () => {
      transport = new WebSocketTransport({ endpoint: 'ws://localhost:3000/stream' })
      await transport.connect()

      const sendSpy = vi.spyOn((transport as any).ws, 'send')

      const data = { type: 'message', content: 'Hello' }
      await transport.send(data)

      expect(sendSpy).toHaveBeenCalledWith(JSON.stringify(data))
    })
  })

  describe('message handling', () => {
    it('should parse JSON messages', async () => {
      transport = new WebSocketTransport({ endpoint: 'ws://localhost:3000/stream' })

      const eventListener = vi.fn()
      transport.on('event', eventListener)

      await transport.connect()

      const ws = (transport as any).ws as MockWebSocket
      ws.simulateMessage({ type: 'token', token: 'Hello' })

      expect(eventListener).toHaveBeenCalledWith(
        expect.objectContaining({
          type: 'token',
          token: 'Hello',
        })
      )
    })

    it('should handle multiple messages', async () => {
      transport = new WebSocketTransport({ endpoint: 'ws://localhost:3000/stream' })

      const eventListener = vi.fn()
      transport.on('event', eventListener)

      await transport.connect()

      const ws = (transport as any).ws as MockWebSocket
      ws.simulateMessage({ type: 'token', token: 'Hello' })
      ws.simulateMessage({ type: 'token', token: ' world' })

      expect(eventListener).toHaveBeenCalledTimes(2)
    })

    it('should handle done signal', async () => {
      transport = new WebSocketTransport({ endpoint: 'ws://localhost:3000/stream' })

      const doneListener = vi.fn()
      transport.on('done', doneListener)

      await transport.connect()

      const ws = (transport as any).ws as MockWebSocket
      ws.simulateMessage({ type: 'done' })

      expect(doneListener).toHaveBeenCalled()
    })

    it('should handle error messages', async () => {
      transport = new WebSocketTransport({ endpoint: 'ws://localhost:3000/stream' })

      const errorListener = vi.fn()
      transport.on('error', errorListener)

      await transport.connect()

      const ws = (transport as any).ws as MockWebSocket
      ws.simulateMessage({ type: 'error', error: 'Something went wrong' })

      expect(errorListener).toHaveBeenCalled()
    })

    it('should handle malformed JSON', async () => {
      transport = new WebSocketTransport({ endpoint: 'ws://localhost:3000/stream' })

      const errorListener = vi.fn()
      transport.on('error', errorListener)

      await transport.connect()

      const ws = (transport as any).ws as MockWebSocket
      if (ws.onmessage) {
        ws.onmessage({ data: '{invalid json}' })
      }

      // Should emit error but not crash
      expect(errorListener).toHaveBeenCalled()
    })
  })

  describe('reconnection', () => {
    it('should reconnect on connection loss', async () => {
      let connectCount = 0
      const OriginalWebSocket = global.WebSocket

      class ReconnectWebSocket extends MockWebSocket {
        constructor(url: string, protocols?: string | string[]) {
          super(url, protocols)
          connectCount++

          if (connectCount === 1) {
            // First connection fails
            setTimeout(() => {
              this.readyState = MockWebSocket.CLOSED
              if (this.onclose) {
                this.onclose({ type: 'close', code: 1006, reason: 'Connection lost' })
              }
            }, 10)
          } else {
            // Subsequent connections succeed
            setTimeout(() => {
              this.readyState = MockWebSocket.OPEN
              if (this.onopen) {
                this.onopen({ type: 'open' })
              }
            }, 10)
          }
        }
      }

      global.WebSocket = ReconnectWebSocket as any

      transport = new WebSocketTransport({
        endpoint: 'ws://localhost:3000/stream',
        reconnect: true,
        maxReconnectAttempts: 3,
        reconnectDelay: 10,
      })

      const reconnectingListener = vi.fn()
      const errorListener = vi.fn()
      transport.on('reconnecting', reconnectingListener)
      transport.on('error', errorListener)

      await transport.connect()

      // Give time for reconnection
      await new Promise(resolve => setTimeout(resolve, 100))

      expect(reconnectingListener).toHaveBeenCalled()
      expect(connectCount).toBeGreaterThan(1)

      global.WebSocket = OriginalWebSocket
    })

    it('should respect maxReconnectAttempts limit', async () => {
      let connectCount = 0
      const OriginalWebSocket = global.WebSocket

      class FailingWebSocket extends MockWebSocket {
        constructor(url: string, protocols?: string | string[]) {
          super(url, protocols)
          connectCount++

          setTimeout(() => {
            this.readyState = MockWebSocket.CLOSED
            if (this.onclose) {
              this.onclose({ type: 'close', code: 1006, reason: 'Connection lost' })
            }
          }, 5)
        }
      }

      global.WebSocket = FailingWebSocket as any

      transport = new WebSocketTransport({
        endpoint: 'ws://localhost:3000/stream',
        reconnect: true,
        maxReconnectAttempts: 1,  // Just 1 retry attempt for faster, deterministic testing
        reconnectDelay: 10,
      })

      const errorListener = vi.fn()
      const reconnectingListener = vi.fn()
      transport.on('error', errorListener)
      transport.on('reconnecting', reconnectingListener)

      await transport.connect()

      // Wait for the single reconnection attempt to complete
      await new Promise(resolve => setTimeout(resolve, 50))

      // Should have exactly: 1 initial + 1 retry = 2 connections
      expect(connectCount).toBe(2)
      expect(reconnectingListener).toHaveBeenCalledTimes(1)
      expect(reconnectingListener).toHaveBeenCalledWith(
        expect.objectContaining({
          attempt: 1,
          maxAttempts: 1,
        })
      )

      global.WebSocket = OriginalWebSocket
    })

    it('should use exponential backoff for reconnection delays', async () => {
      const delays: number[] = []
      const OriginalWebSocket = global.WebSocket

      class FailingWebSocket extends MockWebSocket {
        constructor(url: string, protocols?: string | string[]) {
          super(url, protocols)

          // Always fail to trigger reconnection
          setTimeout(() => {
            this.readyState = MockWebSocket.CLOSED
            if (this.onclose) {
              this.onclose({ type: 'close', code: 1006, reason: 'Connection lost' })
            }
          }, 5)
        }
      }

      global.WebSocket = FailingWebSocket as any

      transport = new WebSocketTransport({
        endpoint: 'ws://localhost:3000/stream',
        reconnect: true,
        maxReconnectAttempts: 2,  // Use 2 attempts to verify exponential backoff
        reconnectDelay: 100,
        backoffMultiplier: 2,
      })

      const errorListener = vi.fn()
      const reconnectingListener = vi.fn((event: any) => {
        delays.push(event.delay)
      })
      transport.on('error', errorListener)
      transport.on('reconnecting', reconnectingListener)

      await transport.connect()

      // Give time for reconnection attempts to complete
      await new Promise(resolve => setTimeout(resolve, 500))

      // Should have exponential backoff pattern: 100ms, 200ms
      expect(delays.length).toBe(2)
      expect(delays[0]).toBe(100)
      expect(delays[1]).toBe(200)

      global.WebSocket = OriginalWebSocket
    })

    it('should emit reconnecting event with attempt number', async () => {
      let connectCount = 0
      const OriginalWebSocket = global.WebSocket

      class FailingWebSocket extends MockWebSocket {
        constructor(url: string, protocols?: string | string[]) {
          super(url, protocols)
          connectCount++

          if (connectCount === 1) {
            // First connection fails
            setTimeout(() => {
              this.readyState = MockWebSocket.CLOSED
              if (this.onclose) {
                this.onclose({ type: 'close', code: 1006, reason: 'Connection lost' })
              }
            }, 10)
          } else {
            // Second connection succeeds
            setTimeout(() => {
              this.readyState = MockWebSocket.OPEN
              if (this.onopen) {
                this.onopen({ type: 'open' })
              }
            }, 10)
          }
        }
      }

      global.WebSocket = FailingWebSocket as any

      transport = new WebSocketTransport({
        endpoint: 'ws://localhost:3000/stream',
        reconnect: true,
        maxReconnectAttempts: 1,
        reconnectDelay: 10,
      })

      const errorListener = vi.fn()
      const reconnectingListener = vi.fn()
      transport.on('error', errorListener)
      transport.on('reconnecting', reconnectingListener)

      await transport.connect()

      // Give time for reconnection
      await new Promise(resolve => setTimeout(resolve, 100))

      expect(reconnectingListener).toHaveBeenCalledWith(
        expect.objectContaining({
          attempt: 1,
          delay: 10,
        })
      )

      global.WebSocket = OriginalWebSocket
    })

    it('should not reconnect if reconnect is disabled', async () => {
      let connectCount = 0
      const OriginalWebSocket = global.WebSocket

      class FailingWebSocket extends MockWebSocket {
        constructor(url: string, protocols?: string | string[]) {
          super(url, protocols)
          connectCount++

          setTimeout(() => {
            this.readyState = MockWebSocket.CLOSED
            if (this.onclose) {
              this.onclose({ type: 'close', code: 1006, reason: 'Connection lost' })
            }
          }, 10)
        }
      }

      global.WebSocket = FailingWebSocket as any

      transport = new WebSocketTransport({
        endpoint: 'ws://localhost:3000/stream',
        reconnect: false,
      })

      const errorListener = vi.fn()
      const reconnectingListener = vi.fn()
      transport.on('error', errorListener)
      transport.on('reconnecting', reconnectingListener)

      await transport.connect()

      // Give time to ensure no reconnection
      await new Promise(resolve => setTimeout(resolve, 100))

      expect(connectCount).toBe(1)
      expect(reconnectingListener).not.toHaveBeenCalled()

      global.WebSocket = OriginalWebSocket
    })
  })

  describe('close', () => {
    it('should close the connection', async () => {
      transport = new WebSocketTransport({ endpoint: 'ws://localhost:3000/stream' })
      await transport.connect()

      const closedPromise = new Promise<void>(resolve => {
        transport.on('closed', () => resolve())
      })

      transport.close()

      await closedPromise
      expect(transport.getState()).toBe('closed')
    })

    it('should emit closed event', async () => {
      transport = new WebSocketTransport({ endpoint: 'ws://localhost:3000/stream' })
      await transport.connect()

      const closedPromise = new Promise<void>(resolve => {
        transport.on('closed', () => resolve())
      })

      transport.close()

      await closedPromise
      // Test passes if promise resolves
    })

    it('should close WebSocket connection', async () => {
      transport = new WebSocketTransport({ endpoint: 'ws://localhost:3000/stream' })
      await transport.connect()

      const ws = (transport as any).ws as MockWebSocket
      const closeSpy = vi.spyOn(ws, 'close')

      const closedPromise = new Promise<void>(resolve => {
        transport.on('closed', () => resolve())
      })

      transport.close()

      await closedPromise
      expect(closeSpy).toHaveBeenCalled()
    })

    it('should prevent reconnection after explicit close', async () => {
      let connectCount = 0
      const OriginalWebSocket = global.WebSocket

      class ReconnectWebSocket extends MockWebSocket {
        constructor(url: string, protocols?: string | string[]) {
          super(url, protocols)
          connectCount++
          setTimeout(() => {
            this.readyState = MockWebSocket.OPEN
            if (this.onopen) {
              this.onopen({ type: 'open' })
            }
          }, 5)
        }
      }

      global.WebSocket = ReconnectWebSocket as any

      transport = new WebSocketTransport({
        endpoint: 'ws://localhost:3000/stream',
        reconnect: true,
        maxReconnectAttempts: 3,
        reconnectDelay: 5,
      })

      await transport.connect()

      const initialCount = connectCount

      const closedPromise = new Promise<void>(resolve => {
        transport.on('closed', () => resolve())
      })

      transport.close()
      await closedPromise

      // Give time to ensure no reconnection
      await new Promise(resolve => setTimeout(resolve, 50))

      expect(connectCount).toBe(initialCount)

      global.WebSocket = OriginalWebSocket
    })
  })

  describe('state management', () => {
    it('should track connection state', async () => {
      transport = new WebSocketTransport({ endpoint: 'ws://localhost:3000/stream' })

      expect(transport.getState()).toBe('idle')

      const connectPromise = transport.connect()
      expect(['idle', 'connecting']).toContain(transport.getState())

      await connectPromise
      expect(transport.getState()).toBe('connected')

      const closedPromise = new Promise<void>(resolve => {
        transport.on('closed', () => resolve())
      })

      transport.close()
      await closedPromise
      expect(transport.getState()).toBe('closed')
    })

    it('should handle error state', async () => {
      const OriginalWebSocket = global.WebSocket

      class ErrorWebSocket extends MockWebSocket {
        constructor(url: string, protocols?: string | string[]) {
          super(url, protocols)
          setTimeout(() => {
            this.readyState = MockWebSocket.CLOSED
            if (this.onerror) {
              this.onerror({ error: new Error('Connection failed') })
            }
            if (this.onclose) {
              this.onclose({ type: 'close', code: 1006, reason: 'Connection failed' })
            }
          }, 5)
        }
      }

      global.WebSocket = ErrorWebSocket as any

      transport = new WebSocketTransport({
        endpoint: 'ws://localhost:3000/stream',
        reconnect: false,
      })

      const errorListener = vi.fn()
      transport.on('error', errorListener)

      await transport.connect()

      // Give time for error to be handled
      await new Promise(resolve => setTimeout(resolve, 20))

      expect(transport.getState()).toBe('error')

      global.WebSocket = OriginalWebSocket
    })
  })

  describe('ping/pong heartbeat', () => {
    it('should send ping messages when configured', async () => {
      transport = new WebSocketTransport({
        endpoint: 'ws://localhost:3000/stream',
        heartbeatInterval: 50, // Very short interval for testing
      })

      // Set up spy before connection to capture all send calls
      let ws: MockWebSocket
      let sendSpy: any
      const connectPromise = transport.connect()

      // Wait for WebSocket to be created
      await new Promise(resolve => setTimeout(resolve, 10))
      ws = (transport as any).ws as MockWebSocket
      sendSpy = vi.spyOn(ws, 'send')

      await connectPromise

      // Wait for at least one heartbeat to fire
      await new Promise(resolve => setTimeout(resolve, 100))

      expect(sendSpy).toHaveBeenCalledWith(
        JSON.stringify({ type: 'ping' })
      )
    }, 5000)

    it('should not send heartbeat if not configured', async () => {
      transport = new WebSocketTransport({
        endpoint: 'ws://localhost:3000/stream',
      })

      const errorListener = vi.fn()
      transport.on('error', errorListener)

      await transport.connect()

      const ws = (transport as any).ws as MockWebSocket
      const sendSpy = vi.spyOn(ws, 'send')

      // Wait for potential heartbeat
      await new Promise(resolve => setTimeout(resolve, 100))

      expect(sendSpy).not.toHaveBeenCalled()

      const closedPromise = new Promise<void>(resolve => {
        transport.on('closed', () => resolve())
      })
      transport.close()
      await closedPromise
    })

    it('should maintain heartbeat during connection', async () => {
      transport = new WebSocketTransport({
        endpoint: 'ws://localhost:3000/stream',
        heartbeatInterval: 40, // Very short interval for testing
      })

      await transport.connect()

      const ws = (transport as any).ws as MockWebSocket
      const sendSpy = vi.spyOn(ws, 'send')

      // Wait for first heartbeat
      await new Promise(resolve => setTimeout(resolve, 60))
      expect(sendSpy).toHaveBeenCalledWith(JSON.stringify({ type: 'ping' }))

      // Wait for second heartbeat
      await new Promise(resolve => setTimeout(resolve, 60))
      expect(sendSpy).toHaveBeenCalledTimes(2)
    }, 5000)

    it('should detect connection failure via heartbeat timeout', async () => {
      vi.useFakeTimers()

      transport = new WebSocketTransport({
        endpoint: 'ws://localhost:3000/stream',
        heartbeatInterval: 30000,
      })

      const errorListener = vi.fn()
      transport.on('error', errorListener)

      const connectPromise = transport.connect()
      await vi.advanceTimersByTimeAsync(0)
      await connectPromise

      const ws = (transport as any).ws as MockWebSocket
      const sendSpy = vi.spyOn(ws, 'send')

      ws.readyState = MockWebSocket.CLOSED

      await vi.advanceTimersByTimeAsync(30000)
      expect(sendSpy).not.toHaveBeenCalled()

      transport.close()
      vi.useRealTimers()
    })

    it('should handle heartbeat response (pong)', async () => {
      transport = new WebSocketTransport({
        endpoint: 'ws://localhost:3000/stream',
        heartbeatInterval: 50, // Very short interval for testing
      })

      const eventListener = vi.fn()
      transport.on('event', eventListener)

      await transport.connect()

      const ws = (transport as any).ws as MockWebSocket
      const sendSpy = vi.spyOn(ws, 'send')

      // Wait for at least one heartbeat to fire
      await new Promise(resolve => setTimeout(resolve, 100))
      expect(sendSpy).toHaveBeenCalledWith(JSON.stringify({ type: 'ping' }))

      // Simulate pong response
      ws.simulateMessage({ type: 'pong' })
      expect(eventListener).toHaveBeenCalledWith(
        expect.objectContaining({ type: 'pong' })
      )
    }, 5000)

    it('should clear heartbeat on disconnect', async () => {
      vi.useFakeTimers()

      transport = new WebSocketTransport({
        endpoint: 'ws://localhost:3000/stream',
        heartbeatInterval: 30000,
      })

      const errorListener = vi.fn()
      transport.on('error', errorListener)

      const connectPromise = transport.connect()
      await vi.advanceTimersByTimeAsync(0)
      await connectPromise

      const ws = (transport as any).ws as MockWebSocket
      const sendSpy = vi.spyOn(ws, 'send')

      transport.close()

      await vi.advanceTimersByTimeAsync(30000)
      expect(sendSpy).not.toHaveBeenCalled()

      vi.useRealTimers()
    })

    it('should send ping at configured intervals', async () => {
      transport = new WebSocketTransport({
        endpoint: 'ws://localhost:3000/stream',
        heartbeatInterval: 30, // Very short interval for testing
      })

      await transport.connect()

      const ws = (transport as any).ws as MockWebSocket
      const sendSpy = vi.spyOn(ws, 'send')

      // Wait for first ping
      await new Promise(resolve => setTimeout(resolve, 50))
      expect(sendSpy).toHaveBeenCalledTimes(1)
      expect(sendSpy).toHaveBeenCalledWith(JSON.stringify({ type: 'ping' }))

      // Wait for second ping
      await new Promise(resolve => setTimeout(resolve, 40))
      expect(sendSpy).toHaveBeenCalledTimes(2)

      // Wait for third ping
      await new Promise(resolve => setTimeout(resolve, 40))
      expect(sendSpy).toHaveBeenCalledTimes(3)

      // Wait for fourth ping
      await new Promise(resolve => setTimeout(resolve, 40))
      expect(sendSpy).toHaveBeenCalledTimes(4)
    }, 5000)
  })
})
